[["index.html", "Introduction to Statistical Computing: R Before getting started… Why R? What is RStudio? Install R and RStudio Coding in R", " Introduction to Statistical Computing: R Heejoon Ahn, MS; Eun Jeung Oh, PhD; and Codruta Chiuzan, PhD February 06, 2023 Before getting started… Why R? R is a FREE, open-source, statistical software R is one of the widely used programming languages A go-to language for Statistics Conventionally, R was mostly used in academia but with the emergence of Data Science, the need for R in industries became evident. What is RStudio? Free, open-source IDE (integrated development environment) for R User-friendly Provided by Posit: https://posit.co Note: RStudio has been rebranded to Posit and launched their website in October 2022. The rebranding allowed users of the open source software for R, Python, and other coding languages. They have also provided more machine and deep learning packages for users! The following image below demonstrates what RStudio is consisted of: RStudio has recently rebranded itself as Posit. They advertised as providing a multi-lingual data science, open-source and commercial software for R, Python, and beyond. Because of this rebranding, we will be using the products that they have just recently released. Install R and RStudio Install R The first thing to download and install is R through this link: https://cran.r-project.org/ (for Windows, Mac, Linux). From the website, click on the “Download R for…” for your computer type. If you are using a Windows computer for this course series, click on the “base” version if you don’t have R installed already. If you are using a Linux computer for this course series, click on the proper version of the Linux device you have. If you are using a Mac computer for this course series, scroll down to “Latest release:” section and on the left-hand side, click on the most recent version of R (R-4.2.2 pkg) NOTE: Due to Mac’s new conversion from Intel to their M1 (and higher) devices, R now provides two separate versions of the R language based on the device type. The messages under Latest release: should be read as follows: For those using the M1 (or higher) devices: R 4.2.2 binary for macOS 11 (Big Sur) and higher, Apple silicon arm64 build, signed and notarized package. Contains R 4.2.2 framework, R.app GUI 1.79 for Apple silicon Macs (M1 and higher), Tcl/Tk 8.6.12 X11 libraries and Texinfo 6.8. Important: this version does NOT work on older Intel-based Macs - see below for Intel version. For those using the Intel 64-bit devices: R 4.2.2 binary for macOS 10.13 (High Sierra) and higher, Intel 64-bit (older Macs) build, signed and notarized package. Contains R 4.2.2 framework, R.app GUI 1.79 in 64-bit for Intel Macs, Tcl/Tk 8.6.6 X11 libraries and Texinfo 6.7. Install RStudio Downloading RStudio Desktop: https://posit.co/download/rstudio-desktop/ RStudio Desktop is free to download on the posit website. There are more options available for purchase. Go to “Step 2: Install Rstudio Desktop” button. It should automatically update the button based on your computer type. If you would like to learn more about other options Posit provides, please click on the “Explore More” tab at the top. Within RStudio, you will write code in the panel on the left-hand top side. To code in R, users mainly code within the RStudio software. Open up RStudio on your device. If it is your first time ever using R or RStudio, the IDE might open up with three panels, instead of four. Console Environment/History Files/Plots/Packages/… Here is an example of what it may look like for you if you are opening up RStudio for the very first time: There are multiple ways to open up the “R Script” panel or otherwise known as the Source panel by RStudio. The simplest way is to go to the icon that looks like a sheet of paper with a green plus sign on the top-lefthand corner. This button is a shortcut to help open “New File” based on the type of file you want to create. Once the list of options opens up, click on the “R Script” (this is the first option). This is illustrated below for you as a demonstration: An alternative way to open up a new R Script file is to go to “File” tab, and then scroll to “New File”. Then, click on “R Script”. This should open a Untitled.R file for you that you can save onto your computer or OneDrive (if synced to your device). If you don’t have a code type file like the “R Script” file open, you may not see the Run button in RStudio, make sure you have this open. This file document will help you write and run R code within RStudio. Coding in R How to run/execute the code… Highlight the code and hit the ‘Run’ button Highlight the lines of code or put the cursor on the line and press: Windows &amp; Linux: CTRL + ENTER Mac: Command + Return More keyboard shortcuts here. Create R Script img {vertical-align: top;} R Packages Packages are collections of R functions, data, and compiled code in a well-defined format. The directory where packages are stored is called the library. R comes with a standard set of packages. Others are available for download and installation. Only need to install the package one time. Once installed, they have to be loaded into the session to be used. Once installed, you need to load package whenever you need to use functions from the package. How to install new packages through R code: # install.packages(&quot;PUT THE NAME OF A PACKAGE INSIDE QUOTATION MARKS&quot;) install.packages(&quot;dplyr&quot;) Alternative way to install packages involves clicking on the “Tools” tab in RStudio, and then on “Install Packages…” This opens up a pop-up window where you can type in the various packages you want to install. Solutions for Potential Package Installation Issues Once you have installed R, and then RStudio, you should first try looking into whether you can load certain packages if you are working on a Windows device. One package that works best as a test case is the dplyr package. This package is used commonly among R coders to help with data cleaning and data manipulation. Try testing this following code: &quot;dplyr&quot; %in% rownames(installed.packages()) # Check if you already have dplyr (TRUE/FALSE) install.packages(&quot;dplyr&quot;) # Install dplyr if you do not already have dplyr If you were able to install dplyr without any issue, ignore the instructions and keep reading ahead from the “Loading R Packages” section. After running the command above, and you get a message like that below, you might have to install RTools using the following link: RTools CRAN repository. WARNING: Rtools is required to build R packages but is not currently installed. Please download and install the appropriate version of Rtools before proceeding. After you download and execute the RTools application, you might need to close and re-open RStudio. Once RTools has been properly installed, you will not need to open the application on your device, as it gets integrated into RStudio upon installation. Another possible issue that could arise is that your work computer might be blocking package installation due to firewall issues. You may encounter a message along the lines of shown below: “Installing package into ‘/usr/lib64/R/library’ (as ‘lib’ is unspecified) — Please select a CRAN mirror for use in this session — Error in download.file(url, destfile=f, quiet=TRUE) : unsupported URL scheme” If this is the message you are receiving, try running the code below: # if working with a different package, replace &quot;dplyr&quot; with your package name inside quotation marks install.packages(&quot;dplyr&quot;, dependencies = TRUE, repos = &quot;http://cran.rstudio.com/&quot;) Instead of the warning messages above, you might also see the following message: Warning in install.packages : unable to access index for repository https://cran.rstudio.com/src/contrib: cannot open URL https://cran.rstudio.com/src/contrib/PACKAGES%27 The solution to help with this is to go to “Tools” and then to “Global Options”. This should bring up a window that has a tab called “Packages”. Click on that tab, where it should open up a few checklists. If you see that the item “Use secure download method for HTTP” is checked, un-check that item and then click “Apply” and “OK” to save your preferences. Doing so will open up RStudio to access libraries such as gtsummary and others that might have previously been blocked by the firewall when it was selected. Now try the install.package() function again and see if it works. This might prompt you to a window asking you whether you want to restart RStudio: Select “No”. This should bring you back to RStudio and you should see that it has started the installation process. A “Stop” sign button should appear in your console next to the “broom” icon. This means that it is currently running the install.packages() code for you and that you should wait until it has finished executing the code. Once finished, you should notice that the “Stop” button has disappeared. Loading R Packages How to load packages through R code: # library(&quot;PUT THE NAME OF A PACKAGE (NO NEED FOR QUOTATION MARKS)&quot;) library(dplyr) mutate() # Using the function from the package &quot;dplyr&quot; # Using one function from a specific package, but without loading the entire package via library() dplyr::mutate() You might have noticed that in the last line of code above, the function from a package was called using the :: notation. This is optional and mostly suggested for when you have loaded multiple packages that may have functions with the same function name. R is open-source and people can upload and publish a package they created, leading to potential overlaps as such. To make sure you are using a specific function from a specific package, this is a useful method to call a function. You also don’t have to call library() if you use the :: notation. If you require assistance with certain packages and functions, please go to the “Help” tab as shown below: R Syntax The word “syntax” can be defined as the way how a code is written through combinations of symbols (much like grammar). Each coding language has a unique syntax to differentiate themselves from other languages. Here is a list of descriptions about R’s syntax: R is an object-oriented programming language. Users can define not only the type of the data structure, but also the type of functions to be applied to the data. R is case sensitive: 'A' and 'a' are different symbols according to R. Commands are separated by a new line (commonly by a new line). Commands can be grouped together (in functions) by { and }. Comments can be inserted almost anywhere. Comments are essentially notes you write for yourself and others. This is to help document your work. Starts with a #, until the end of the line (single-line comment). A quick way to comment multiple lines instead of just one, select all the lines of interest and then press: Windows &amp; Linux: CTRL + Shift + C Mac: Command + Shift + C R Errors Occasionally, while you run code, you may run into various types of error messages. This is typically normal, and a way for the R program to notify you that there is something in your code that prevents it from finishing to run the code. It will stop running at the source of the error in your code. The following are some of the most common error messages R users have seen: Syntax Errors: generated by misspelling, and extra comma, or forgetting to close a bracket. Semantic Errors: correct code, but the outcome is NOT what you expected. Logic Errors: this is the worst type of error you can see. The mistake is not in the code, but the logic of execution. To resolve this, read the error message carefully, since R provides the line the error occurred in, and RStudio displays the line numbers in the R Script file. "],["introduction-to-r.html", "Introduction to R Understanding Basic Data Types and Data Structures Fundamentals of R Data Structures", " Introduction to R This section is an introductory guide to R provided as a reference for basic R. Much of this section is not part of the three-part lessons provided by this course series. This is to introduce some concepts about R variables, data types, and data structures for those who do not have any experience working with R or coding in general. Warning: package &#39;dplyr&#39; was built under R version 4.2.2 Understanding Basic Data Types and Data Structures Before we dive right into importing data and analysis, we first need to understand of the various data types and data structures in R. Everything in R can be considered an object. A variable is a letter, word, series of letters and numbers that is assigned a value. These values can be categorized into the following data types: Table 0.1: Common Data Types in R Data Type Values Example Character Set of all alphabets and special characters “a”, “b”, “c”, “cat”, “$”, “1”, “2”, … Numeric Set of all real numbers 1, 1.1, 2.0, 3.5 Integer Set of all integers, Z 1, 2, 3, 4, 5 Logical TRUE and FALSE TRUE, FALSE Complex Set of complex numbers (includes real and imaginary parts) 1+4i If you are unsure of a variable’s data type, you can use the class function. This function outputs which data type a variable or data column consists of. x &lt;- 2.3 class(x) [1] &quot;numeric&quot; Variables When naming a variable like var1, there are a few rules. A valid variable name consists of a combination of alphabets, numbers, dot(.), and underscore (_) characters. Example: var.1_ is valid No other special character is allowed except for the dot and underscore. Variables can start with alphabets or dot characters. If a variable starts with a dot, the next thing should never be a number. The variable should not start with numbers or underscore. Variables can be declared/initialized with a certain data type in various ways: Using the = operator: data is copied from right to left Using the &lt;- operator: data is copied from right to left Using the -&gt; operator: data is copied from left to right Using the = operator: # using the = operator var1 = &quot;hello, world!&quot; print(var1) [1] &quot;hello, world!&quot; Using the &lt;- operator: data is copied from right to left # using the &lt;- operator var2 &lt;- &quot;hello, world!&quot; print(var2) [1] &quot;hello, world!&quot; Using the -&gt; operator: data is copied from left to right # using the -&gt; operator &quot;hello, world!&quot; -&gt; var3 print(var3) [1] &quot;hello, world!&quot; Fundamentals of R Comments are mostly used for various purposes, these can include: Prevent execution of code Code Readability Writing Notes Explanation of the code or Metadata of the project To include resources There are multiple ways to write codes. There is a single-line comment format in R. The comment symbol in R is the # key. Here is a demonstration of how to use comments in R: # Print &quot;Hello World&quot;! print(&quot;hello world!&quot;) [1] &quot;hello world!&quot; Using #' in R allows you to keep writing comments after you press Enter on the keyboard automatically: #&#39; Defining the variables used to help calculate the sum of a list of values: #&#39; y = x = 2 #&#39; z = x + y x &lt;- 2 y &lt;- x (z &lt;- x + y) [1] 4 You might have noticed that in the second demonstration, to make the code “print” out the output, the function print() was not used. Instead, the assignment of z &lt;- x + y was surrounded in (). Doing this works essentially the same as print() in R. Operators The following are arithmetic operators (symbols) that are used in R: +: Addition -: Subtraction *: Multiplication /: Division ^: Power %%: Modulo The modulo operator gets the remainder values from an “x” value divided by the “y” value You can do arithmetic operations for numerical values or vectors. A vector is a sequence of data elements of the same basic types and considered the simplest data structures. Vectors with values x and y are notated in R like this: c(x, y). x &lt;- 9 y &lt;- 2 # Performing operations cat(&quot; Addition:&quot;, x + y, &quot;\\n&quot;, &quot;Subtraction:&quot;, x - y, &quot;\\n&quot;, &quot;Multiplication:&quot;, x * y, &quot;\\n&quot;, &quot;Division:&quot;, x/y, &quot;\\n&quot;, &quot;Power:&quot;, x^y, &quot;\\n&quot;, &quot;Modulo:&quot;, x%%y) Addition: 11 Subtraction: 7 Multiplication: 18 Division: 4.5 Power: 81 Modulo: 1 The next section discusses logical operators used in R. These generate TRUE/FALSE boolean values. Any condition that is a non-zero value returns TRUE. Otherwise, it is returned as FALSE. &amp;: element-wise AND operator. &amp;&amp;: logical AND operator |: element-wise OR operator ||: logical OR operator !: NOT operator Simply put, the element-wise &amp; and |are vectorized, and if used in a list of values, will return a vector. The logical &amp;&amp; and || only return a single value based on whether the first element of the operand is TRUE. vec1 &lt;- c(0, 5) vec2 &lt;- c(TRUE, FALSE) # Performing operations cat(&quot; Element wise AND:&quot;, vec1 &amp; vec2, &quot;\\n&quot;, &quot;Logic AND:&quot;, vec1 &amp;&amp; vec2, &quot;\\n&quot;, &quot;Element wise OR:&quot;, vec1 | vec2, &quot;\\n&quot;, &quot;Logic OR:&quot;, vec1 || vec2, &quot;\\n&quot;, &quot;Negation:&quot;, !vec1) Element wise AND: FALSE FALSE Logic AND: FALSE Element wise OR: TRUE TRUE Logic OR: TRUE Negation: TRUE FALSE Relational operators are next, where it does comparison operations between corresponding elements. &lt;: Less than &gt;: Greater than &lt;=: Less than or equal to &gt;=: Greater than or equal to ==: Equal to !=: Not equal to These comparisons are done element-wise and if two lists are compared to each other, the returning output would also be a list of the same number of items in the list. vec1 &lt;- c(2, 4) vec2 &lt;- c(1, 5) # Performing operations cat(&quot; Vector 1 less than Vector 2:&quot;, vec1 &lt; vec2, &quot;\\n&quot;, &quot;Vector 1 greater than Vector 2:&quot;, vec1 &gt; vec2, &quot;\\n&quot;, &quot;Vector 1 less than or equal to Vector 2:&quot;, vec1 &lt;= vec2, &quot;\\n&quot;, &quot;Vector 1 greater than or equal to Vector 2:&quot;, vec1 &gt;= vec2, &quot;\\n&quot;, &quot;Vector 1 equal to Vector 2:&quot;, vec1 == vec2, &quot;\\n&quot;, &quot;Vector 1 not equal to Vector 2:&quot;, vec1 != vec2) Vector 1 less than Vector 2: FALSE TRUE Vector 1 greater than Vector 2: TRUE FALSE Vector 1 less than or equal to Vector 2: FALSE TRUE Vector 1 greater than or equal to Vector 2: TRUE FALSE Vector 1 equal to Vector 2: FALSE FALSE Vector 1 not equal to Vector 2: TRUE TRUE Keywords There are a set of reserved words in R called keywords. These include… if: a conditional statement that determines whether a section of code will be executed or not by condition. else: similar to the if statement, but for when the condition(s) are not met/fails. while: a loop controlled by a condition. The loop stops running once the condition reaches the result of FALSE. for: a loop normally used to iterate over items of a sequence. function: this allows you to run certain lines of code when you call for them. break: a jump statement that terminates a loop at a particular iteration. TRUE/FALSE: keywords used to represent Boolean true and false. NULL: This is used to represent missing and undefined values. Inf: This stands for the number “infinity”. NaN: This stands for “Not a Number” NA: This stands for “Not Available” and is used to represent missing values. etc. The if and else statement typically go hand-in-hand. Inside the if() statement, you write the condition that has to be met to generate a certain code. And for the situation that the condition is not met, you use the else statement. You can have multiple if() statements if you wanted to set multiple conditions until you reach the else statement. When you add multiple conditions for the if() statement, you must use one if() statement at the beginning, and in the middle, use else if() before you use else statement. # Assign a value to x x &lt;- 5 # First if/else statement if(x &gt; 10){ print(&quot;x is greater than 10&quot;) } else { print(&quot;x is less than 10&quot;) } [1] &quot;x is less than 10&quot; # Second if/else statement -- multiple if(x &lt; 5){ print(&quot;x is less than 5&quot;) } else if(x &lt; 7 &amp; x &gt;= 5){ print(&quot;x is greater than or equal to 5 but less than 7&quot;) } else if(x &gt;= 7 &amp; x &lt; 10){ print(&quot;x is greater than or equal to 7 but less than 10&quot;) } else { print(&quot;x is greater than or equal to 10&quot;) } [1] &quot;x is greater than or equal to 5 but less than 7&quot; Loops are functions that make blocks of code run iteratively. Essentially it runs the same few lines of code repeatedly based on a condition. Two loops are common in R: while loop and for loops. The while() loop typically will run repeatedly until a certain condition is met. For example if you have the value x = 1, you can set a condition to say print(x) and x &lt;- x + 1 inside the loop until x &gt;= 5. Ultimately, this will print out 1, 2, 3, 4, and 5. It will never print an x value from 6 or greater since the condition for the loop to ever run is if the value of x is less than or equal to 5. x &lt;- 1 # Set x to a value of 1 while(x &lt;= 5){ # while x is less than or equal to 5 print(x) # print x x &lt;- x+1 # add a value of 1 to x } # Stop printing x if while loop condition is not met [1] 1 [1] 2 [1] 3 [1] 4 [1] 5 The for() loop is typically used to repeatedly run certain code based on the items of a sequence. For example, if you have a vector x with the values 2, 4, 6, 8, and 10 and you want to print each value from x, the code loops through designated vector indices (the location of the item in a vector). When designating a vector with a set of consecutive sequence of numbers, you can use the : symbol instead of listing them out one-by-one. You can use length(x) to get the number of items in the vector x. If length(x) returns a value of 0, it means the vector is empty. The index of a vector is marked with square brackets []. The idx is the placeholder for the variable in the sequence that is being currently running. The first run of the example code below would make idx equal to 1. x &lt;- c(2, 4, 6, 8, 10) # set a list of values to variable x for(idx in 1:length(x)){ # for each position in the list x, print(x[idx]) # print the item from list x in that position } [1] 2 [1] 4 [1] 6 [1] 8 [1] 10 The break statement helps to essentially “interrupt” the code and stop it running. This is typically used in if() statements or in loops. val &lt;- 1 # Set value of 1 to variable &quot;val&quot; while(val &lt; 10){ # While val is less than 10 if(val == 5){ # &amp; if the val reaches a value of 5 break # Stop the loop! } else { # Otherwise, print(val) # print variable &quot;val&quot; val &lt;- val + 1 # Add one to &quot;val&quot; } } [1] 1 [1] 2 [1] 3 [1] 4 Functions are essentially statements that allow you to wrap lines of code inside them so that they only run when you call upon them later. Functions also allow you to put inputs and define them so that you can change the output depending on what code is wrapped inside. When you use function(), you must have a return() statement. The return() is what provides you with the output of the function. # Make a function to determine if a number is even or odd evenOdd &lt;- function(x){ if(x %% 2 == 0){ # If dividing by 2 returns a remainder of 0: return (&quot;even&quot;) # return the string/message &quot;even&quot; } else { # else return(&quot;odd&quot;) # return the string/message &quot;odd&quot; } } evenOdd(4) [1] &quot;even&quot; Data Structures There are a variety of data structures in R. The one most frequently used in R are the following: Table 0.2: Common Data Structures in R Data Structure Explanation Vectors An ordered collection of basic data types of a given length. (homogeneous data structure) Lists A generic object containing ordered collection of objects. (heterogeneous data structure) Dataframes Data object used to store tabular data. (two-dimensional, heterogenous data structure) Matrices rectangular arrange of numbers in rows and columns. (two-dimensional, homogenous data structure) Arrays Data object that stores data in more than two dimensions. (n-dimensional homogenous data structure) We will be focusing mostly on the Dataframes for this R Workshop series. Here is a brief explanation of dataframes. A dataframe consists of columns and rows. When grabbing a certain row and/or column from a dataframe X, you put in the row indices/row names and column indices/column names inside square brackets separated by a column ,. The row indices/names go on the left-hand side of the comma. The column indices/names go on the right-hand side of the comma. In R, we can also access the columns by using the $ symbol. You can view a list of the column names by typing colname(x) where x is the dataframe. Each column and each row, are individually considered as “vectors”. In R, you can subset or filter your dataframe to view certain parts of the dataframe by a condition. You can also edit the dataframes by deleting or adding rows or columns. When adding columns or rows, you have to make sure that the dimensions match that of the dataframe’s. It is good practice to re-assign your raw data to another variable name (that makes sense) so that you don’t need to start over from the very beginning! "],["overview-of-rr-studio-examining-data-attributes-and-data-manipulation.html", "1 Overview of R/R Studio, Examining Data Attributes, and Data Manipulation Importing Data Data Description Data Manipulation", " 1 Overview of R/R Studio, Examining Data Attributes, and Data Manipulation Importing Data Prepare Data R is capable of reading data from most formats. The most common file types are… Excel (.xlsx) CSV (.csv) Text (.txt) JSON (.json) Other formats: SAS, Stata, SPSS, and others. If you are unsure between certain file types on your computer, you can right-click on your file and click “Properties”. This should spell out what type of file your data is. Below, are some useful tips for whenever you work with data files (for .csv and .xlsx files): Reserve the first row for headers (variable/column names) First column is often used to identify sampling units (ID or something else) Avoid variable names or fields with blank spaces; put an underscore _ instead. Delete comments and notes from Excel Denote any missing values as \".\" or NA Avoid symbols such as $, #, *, &lt;, /, - Set Your Working Directory Before reading any data, it is good practice to set the R working directory to the location of the data or project. “Setting” the working directory essentially allows you to instruct RStudio to gain access to a certain folder on your computer and be able to grab various files from there. A working directory is a folder where you store your data, R code, etc. You can set a different directory for each project. One way to set the working directory is through RStudio, where you can click Session and then to Set Working Directory. This should provide you a way to manually select your working directory. If you use this method, it is good practice to note somewhere in your R code file (via comment) of where you set your working directory for that code file. An alternative way to set your working directory is to do it through R code. This requires an element called the path. A path is the full name that spells out the location of the working directory. The way this is written is different between Mac and Windows devices. Mac: \"Users/*username*/*folder name*\" Windows: \"C:\\\\Users\\\\*username*\\\\*folder name*\" Recently, RStudio in Windows can also read / the same way as \\\\ for directory paths. So the following will also work in Windows: C:/Users/*username*/*folder name* In order to declare the path, you can use the following code: getwd() # Print out your current working directory setwd(&quot;path to your folder&quot;) # Set your working directory. The current working directory is also depicted in the console location in RStudio and within the panel that contains the “File” tab. img {vertical-align: top;} From the “Files” tab, you can go through the various folders in your computer. Navigate to the folder you want to set as your working directory from that panel. Once you have done so, click on a button that looks like a “cog”. This should open a drop-down menu that you can see multiple options. Some of these options are the following: “Copy Folder Path to Clipboard” “Set as Working Directory” “Go to Working Directory” These are quick and easy ways to either get your folder path, or to set your working directory without code. However, it is highly suggested to code your working directory so that you know where all your files for that R code would have saved. If you are done using a code file, you have the option to remove all objects from the current workspace (R memory) through the following code: rm(list = ls()) The rm() function is one that “removes” objects from the working environment. Or the “environment” tab in RStudio. The ls() function returns a vector of character strings with the names of the objects in the working environment. Altogether, all objects in the “Environment” tab in RStudio are removed. An alternative way to do this is to click on the “broom” icon on the “Environment” tab as depicted below: Read Data into R To read or upload/import data into R, the data must be someplace on the computer where you can access. For this course, the data exists in the “Datasets” folder of the course OneDrive. Please either download the datasets or copy them to your own OneDrive. There are multiple ways to read data into R. One method is to do it through R Code, and the other method is to do it manually under the Files tab. Read .CSV Files .CSV files are also known as comma-separated files. They can be read through various different functions provided by various packages. read.csv(): This function comes from the base package and is already installed in R. read_csv(): This function comes from the readr package. This function runs faster for data files of size \\(\\ge\\) 1 MB. fread(): This function comes from the data.table package. Reads data faster than read.csv() and read_csv(). More efficient for large data files. # Reading .CSV files with read.csv() df &lt;- read.csv(&quot;path to file here/my_data_filename.csv&quot;) # Reading .CSV files with read_csv() library(readr) df &lt;- read_csv(&quot;path to file here/my_data_filename.csv&quot;) # Reading .CSV files with fread() library(data.table) df &lt;- fread(&quot;path to file here/my_data_filename.csv&quot;) If you have already set your working directory, you don’t need to type the full path name. You can type just the file name and it should be able to read in the data from that location. setwd(&quot;path to folder&quot;) read.csv(&quot;mydata.csv&quot;) The functions listed above have various other options that have pre-set default values that you do not need to input. For more example, read the documentation for this by running ?read.csv(). For this R course series, the function that you will be using is read.csv() provided from the base package. If you want try your hand at using the other functions, make sure you have installed and loaded the package tied with the respective function. Read Excel Files read_excel(): This function comes from the readxl package. Good to use with the libraries dplyr and tidyverse. Calls the excel_format() to determine if the path to the file is .xls or .xlsx. library(readxl) dat &lt;- read_excel(&quot;mydata.xls&quot;) # for xls files dat &lt;- read_excel(&quot;mydata.xlsx&quot;) # for xlsx files Read .TXT Files .txt files, or tab-delimited text files, can be read using the read.table() function, which automatically comes with R. This function works similarly to read.csv() but starts with header = FALSE, indicating that there are no column names in the file. If the data does have a header, specify this with header = TRUE in your code like that demonstrated below: dat &lt;- read.table(&quot;mydata.txt&quot;, header = TRUE) Read/Import Data Manually For the manual method, go to the “Files” tab and to the folder that contains your datasets. Once there, you can click on the dataset, which opens up a few options, one of them being “Import Dataset…”. Clicking on the “Import Dataset…” button as shown above should open up a new window within RStudio like that of below. It also gives you a preview of what the data will look like and what kind of data type the data values are. If this is the data file that you would like to import/read, then click on the “Import” button at the bottom of that window. Typically, this method will try to automatically determine which library and function to use to read the data file based on file type (such as .xlsx, .csv, and more). This method works if you are not entirely confident with code, but it is better practice to write and run your code so that you can replicate your own work from a single R Script file. Load Data from R Packages There are more than 100 datasets supplied with R (in package dataset). To see the list of datasets currently available, use the function data(). If a package containing data has been already been loaded by library(), its datasets are automatically included in the search (e.g. esoph). # Load data &quot;esoph&quot; from the R package &quot;datasets&quot; data(esoph, package = &quot;datasets&quot;) esoph Here is what you will see from running the code above: img {vertical-align: top;} Data Description Before running any analysis, it is crucial to examine the data. For instance, you can look to see how many different variables/features are in the data, the variable data types, number of observations, etc. To see what kind of variables are in the dataset, you can use either of the names() or colnames() functions. The difference between the two functions is that colnames() can get column names of both data frames and matrices. names() can only grab column names from data frames. # colnames(esoph) # Using the colnames() function names(esoph) # Using the names() function [1] &quot;agegp&quot; &quot;alcgp&quot; &quot;tobgp&quot; &quot;ncases&quot; &quot;ncontrols&quot; To determine the shape or dimension of the data, you can use the following functions: # Get dimension of a matrix, array, or data frame. dim(esoph) [1] 88 5 # Get number of rows inside a vector, array, or data frame. nrow(esoph) [1] 88 # Get number of columns inside a vector, array, or data frame. ncol(esoph) [1] 5 If you want to preview your data that you read, but the data size is big, you can use either the head() or tail() functions to see just n number of rows of your data. Both functions display 6 rows of data if the n value is not specified. # Look at the first 6 rows head(esoph) agegp alcgp tobgp ncases ncontrols 1 25-34 0-39g/day 0-9g/day 0 40 2 25-34 0-39g/day 10-19 0 10 3 25-34 0-39g/day 20-29 0 6 4 25-34 0-39g/day 30+ 0 5 5 25-34 40-79 0-9g/day 0 27 6 25-34 40-79 10-19 0 7 # Look at the last 6 rows tail(esoph) agegp alcgp tobgp ncases ncontrols 83 75+ 40-79 20-29 0 3 84 75+ 40-79 30+ 1 0 85 75+ 80-119 0-9g/day 1 0 86 75+ 80-119 10-19 1 0 87 75+ 120+ 0-9g/day 2 0 88 75+ 120+ 10-19 1 0 If you want to access specific rows and/or columns of your data, you can use the syntax data[row, col]. row can be a singular number, or a list of numbers to represent the row index. The row number is from 1 to the total number of rows in the dataset. col can be a singular number, or a list of numbers to represent the column index. The column number is from 1 to the total number of columns in the dataset. If a list of numbers are used to represent the row or column indices, they can be written in the following ways: If the list is a series of consecutive numbers, it can be written as x:y where the : represents the word “to”. If the list is not a series, you can put it inside a vector of c(x, y). Instead, if you wanted to look at specific rows/columns of your data, you can use the syntax of data[row, col]. # Get specific rows of the esoph data esoph[4,] esoph[1:3,] esoph[c(1,2,7),] # Get specific columns of the esoph data esoph[,1] esoph[,2:3] esoph[,c(1,3)] # Get specific rows and columns of the esoph data esoph[4,3] esoph[1:3, 1:2] For columns, there is an alternative way to access them. If you use the $ symbol, it selects that specific column for ease of use. # Using $ to access a certain column age &lt;- esoph$agegp Missing Data Datasets can sometimes have little to a lot of missing data. Typically, these are represented in many ways, but the most common type in R are: NA \"\" To check if you have any missing data in your data frame you can use, anyNA(esoph) # check for any missing values [1] FALSE The code above will return TRUE if there is any missing data or FALSE if you do not. If there is any missing data, you can determine where/how frequently missing data occurred: is.na(): returns the data frame as a matrix of whether the data in a certain row and column is a NA value. rowSums(is.na()): returns the total number of NA values in each row. colSums(is.na()): returns the total number of NA values in each column. which(is.na()): returns the vector index of interest for NA values. # Making random dataset dat &lt;- data.frame(x1 = rnorm(5), x2 = c(NA, rnorm(2), NA, NA), x3 = c(NA, rnorm(4))) dat # Check where and how frequently missing observed is.na(dat) rowSums(is.na(dat)) colSums(is.na(dat)) which(is.na(dat$x2)) # Return row index where NA values are located which(is.na(dat[1,])) # Return column index where NA values are located The codes above will generate the following output: knitr::include_graphics(rep(&quot;Images/na_idx.png&quot;)) Data Class To further explore and “describe” your dataset, you can see what kind of data “class” your data consists of. This “class” refers to what kind of data type certain column values are. If you are unfamiliar with the data type that exist in R, please go to the section “Introduction to R” in this webpage to read a summary of this information. To examine what data types exist for all columns you can use the str() function. Here is an example using an example dataset: low_birth_all &lt;- read.csv(&quot;Lowbwt_ALL.csv&quot;) str(low_birth_all) &#39;data.frame&#39;: 3671 obs. of 12 variables: $ id : int 3599133 3226096 1198044 2214416 116196 2764777 2194359 870149 3020763 1030014 ... $ low : int 0 0 0 0 0 0 0 0 0 0 ... $ birthYear : int 2018 2018 2018 2018 2018 2018 2018 2018 2018 2018 ... $ birthMonth : int 1 9 1 5 3 9 2 6 2 5 ... $ age : int 19 28 31 26 27 38 31 35 41 23 ... $ race : chr &quot;white&quot; &quot;white&quot; &quot;white&quot; &quot;white&quot; ... $ prenatalVisits: int 12 15 10 6 11 11 6 15 10 9 ... $ smoke : int 1 0 0 0 0 0 0 0 0 0 ... $ height : int 67 69 60 64 60 66 63 63 64 61 ... $ ht : int 0 0 0 0 0 0 0 0 0 0 ... $ ptl : int 0 0 0 0 0 0 0 0 0 0 ... $ bwt : int 3345 3730 4090 3200 3600 3255 3577 3374 3005 3245 ... From this example, the data has 3,671 rows (observations) and 12 columns (variables). All columns, except race (chr = character), contain numeric values (int = integer) If, by any chance, you wanted to look at only one column’s data type, then you can use the class() function (as demonstrated in the “Introduction to R” chapter). Here is an example using the data above: class(low_birth_all$age) [1] &quot;integer&quot; Count and Proportions of Data In R, there is a way to tabulate your data with the count/proportion information using the table() and prop.table() functions respectively. Generally, used for categorical/binary variables, not for continuous variables. But even for continuous variables, this might be useful. The table() function provides the count for each unique value in a column. # Example: tabulate variable smoke from data low_birth_all: table(low_birth_all$smoke) 0 1 3427 244 # Example: tabulate variable race from data low_birth_all: table(low_birth_all$race) black other white 573 390 2708 If you wanted to tabulate the data across two columns, you are able to do this using the table() function as well: table(low_birth_all$smoke, low_birth_all$race) black other white 0 540 372 2515 1 33 18 193 But if you wanted to get the proportion of the count information, you can use the prop.table() function after running the table() function. # Example: tabulate variable smoke from data low_birth_all: prop.table(table(low_birth_all$smoke)) # Decimal Version 0 1 0.9335331 0.0664669 prop.table(table(low_birth_all$smoke)) * 100 # Percent Version 0 1 93.35331 6.64669 Summary Statistics For continuous variables, you can use the function summary() to get the summary statistics (distribution) of the data. This function returns the following values: Minimum 1st Quartile Median Mean 3rd Quartile Maximum # Example: summarize variable prenatalVisits summary(low_birth_all$prenatalVisits) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 9.00 12.00 11.36 14.00 49.00 If you were to call this function on a categorical column, the number of observations, and column class are returned. Here is what happens when you call summary() on the entire data frame. summary(low_birth_all) id low birthYear birthMonth age race prenatalVisits smoke Min. : 1189 Min. :0.0000 Min. :2018 Min. : 1.000 Min. :14.00 Length:3671 Min. : 0.00 Min. :0.00000 1st Qu.: 980184 1st Qu.:0.0000 1st Qu.:2018 1st Qu.: 4.000 1st Qu.:25.00 Class :character 1st Qu.: 9.00 1st Qu.:0.00000 Median :1965753 Median :0.0000 Median :2018 Median : 7.000 Median :29.00 Mode :character Median :12.00 Median :0.00000 Mean :1934350 Mean :0.0918 Mean :2018 Mean : 6.654 Mean :29.17 Mean :11.36 Mean :0.06647 3rd Qu.:2871162 3rd Qu.:0.0000 3rd Qu.:2018 3rd Qu.:10.000 3rd Qu.:33.00 3rd Qu.:14.00 3rd Qu.:0.00000 Max. :3799040 Max. :1.0000 Max. :2018 Max. :12.000 Max. :50.00 Max. :49.00 Max. :1.00000 height ht ptl bwt Min. :50.00 Min. :0.00000 Min. :0.00000 Min. : 280 1st Qu.:62.00 1st Qu.:0.00000 1st Qu.:0.00000 1st Qu.:2950 Median :64.00 Median :0.00000 Median :0.00000 Median :3315 Mean :64.21 Mean :0.02179 Mean :0.03133 Mean :3257 3rd Qu.:66.00 3rd Qu.:0.00000 3rd Qu.:0.00000 3rd Qu.:3628 Max. :78.00 Max. :1.00000 Max. :1.00000 Max. :5530 Data Manipulation Subset Data For this section the library dplyr is used for data selection and manipulation. If this library is not already installed, please do so. dplyr is a tool to help work with data frame like object for multiple purposes, but mainly for data manipulation. To subset the data by columns, you can select variable(s) that you want using the following functions: select(mydata, colname): In the data table mydata, take out the colname column. select(mydata, colname1, colname2, ...): In the data table mydata, take only the columns colname1, colname2, .... library(dplyr) select(airquality, Ozone) select(airquality, Ozone, Wind, Temp) The fun thing about dplyr is that you can pass the functions through the %&gt;% symbol. This notation is called the pipeline operator and essentially sends along the input value from the left to the next expression/function(s). Typically, that value is the data frame. Here is the same code as above, but written differently: airquality %&gt;% select(Ozone, Wind, Temp) Ozone Wind Temp 1 41 7.4 67 2 36 8.0 72 3 12 12.6 74 4 18 11.5 62 5 NA 14.3 56 6 28 14.9 66 When you want to subset the data by columns, but want to see all columns but a specific column(s), you can use the - symbol within the select() function: select(airquality, -Month, -Day) Ozone Solar.R Wind Temp 1 41 190 7.4 67 2 36 118 8.0 72 3 12 149 12.6 74 4 18 313 11.5 62 5 NA NA 14.3 56 6 28 NA 14.9 66 If you wanted to select only certain rows of the data to subset, you can use the slice() function instead. # Example: select rows 1 to 5 from airquality slice(airquality, 1:5) # Example: select rows 4, 7, and 18 from airquality slice(airquality, c(4, 7, 18)) An alternative method is to use the filter() function to do the same thing as well. For this function, you want to put in the condition or a criteria using the operators for logical comparisons. Here is a review of operators in R: Logical Operators &amp;: element-wise AND operator. |: element-wise OR operator !: NOT operator Logical Comparisons &lt;: Less than &gt;: Greater than &lt;=: Less than or equal to &gt;=: Greater than or equal to ==: Equal to !=: Not equal to is.na() is NA !is.na() is not NA # filter(airquality, Month==7 &amp; Wind &lt; 6) # the same function different way to write it. airquality %&gt;% filter(Month == 7 &amp; Wind &lt; 6) Ozone Solar.R Wind Temp Month Day 1 135 269 4.1 84 7 1 2 64 175 4.6 83 7 5 3 77 276 5.1 88 7 7 4 97 272 5.7 92 7 9 5 79 187 5.1 87 7 19 In dplyr using the %&gt;% also allows to combine multiple dplyr functions for a single code run. You can write multiple lines of code with multiple functions in each new line, followed up with %&gt;% after the function. For example, if you wanted to use both select() and filter() functions, then you can write it like the following: low_birth_all %&gt;% select(-birthYear, -birthMonth) %&gt;% filter(race == &quot;black&quot; &amp; age &gt; 41 &amp; smoke == 0) id low age race prenatalVisits smoke height ht ptl bwt 1 3189399 0 43 black 5 0 67 0 0 3527 2 741026 0 42 black 16 0 66 0 0 2760 3 1653090 0 42 black 11 0 68 1 0 3515 4 798266 0 43 black 5 0 64 0 0 3657 5 1350086 0 42 black 23 0 64 0 1 3220 6 3151450 0 45 black 11 0 66 0 0 3170 7 471085 1 50 black 10 0 67 0 1 1830 Order Data To order rows of data according to one of the variables, you can use the function arrange(mydata, ordering_var). By default, it sorts the row from smallest to largest numerically, or alphabetically if it’s sorting a character-type column. arrange(low_birth_all, id) id low birthYear birthMonth age race prenatalVisits smoke height ht ptl bwt 1 1189 0 2018 2 35 other 18 0 67 0 0 3040 2 1834 0 2018 3 26 white 8 0 62 0 0 2744 3 3244 0 2018 4 29 white 12 0 62 0 0 3816 4 5640 0 2018 8 24 white 13 0 61 0 0 3465 5 5886 0 2018 8 30 white 4 0 67 0 0 3459 6 6128 0 2018 8 26 black 11 0 63 0 0 3540 It is possible to sort the rows in the opposite direction (descending order) using the desc() function inside arrange(). arrange(low_birth_all, desc(id)) You can also sort rows by multiple columns by putting all column names into arrange(). arrange(low_birth_all, smoke, desc(age)) Rename Variables In R, there are multiple ways to rename columns. Without dplyr, you can use colnames() and rename the columns like below: # Rename all columns colnames(low_birth_all) &lt;- c(&quot;ID&quot;, &quot;Low&quot;, &quot;Birth_Year&quot;, &quot;Birth_Month&quot;, &quot;Age&quot;, &quot;Race&quot;, &quot;Prenatal_Visits&quot;, &quot;Smoke&quot;, &quot;Height&quot;, &quot;HT&quot;, &quot;PTL&quot;, &quot;BWT&quot;) # Rename only the third column colnames(low_birth_all)[3] &lt;- &quot;Birth_Year&quot; You can also rename columns through dplyr function rename() using the following syntax: rename(mydata, new_name_var = old_name_var) rename(low_birth_all, smoking_status = smoke) You can also rename multiple columns at once through this function by listing out the new column names: low_birth_all %&gt;% rename(smoking_status = smoke, patientID = id, low_binary = low) Data Transformation Sometimes, you want to create new variable(s) derived from existing ones for your analysis purposes (e.g. apply a log transformation to a skewed variable). To do so, you can use the mutate(mydata, new_name_var = transform_old_var) syntax: mutate(low_birth_all, log_age = log(age)) Here are some other operations that you can do within mutate. The options in the lists are only a handful of the many different ways you can transform the data: Basic Operations: log(): natural logarithm sqrt(): square root x^n: exponent exp(): exponential Matrix Operations: A%*%B: matrix multiplication t(A): matrix transpose det(A): determinant of A diag(A): diagonal of A solve(A): matrix inverse If-Else Function An if-else function is used if you want the assignment statement to apply to some observations and not to all. You need to specify, The logical condition we want to test What should happen in case the logical condition is TRUE What should happen in case the logical condition is FALSE The R function for the if-else function can be written as ifelse(condition, yes, no). # Example: Create a binary category (1 if &lt; 30; 0 otherwise) in data low_birth_all low_birth_all$binary_age &lt;- ifelse(low_birth_all$age &lt; 30, 1, 0) head(low_birth_all) It is possible to use this function to create multiple categories. This will be calling an ifelse() function inside a different ifelse() function. Here is an example: # Example: Create three age categories (&lt;20, 20-29, 30+) in data low_birth_all low_birth_all$age_category &lt;- ifelse(low_birth_all$age &lt; 20, &quot;&lt;20&quot;, ifelse(low_birth_all$age &gt;= 20 &amp; low_birth_all$age &lt; 30, &quot;20-29&quot;, &quot;30+&quot;)) head(low_birth_all) Combine Data Sets (Stacking) In R, there are ways to combine multiple data sets that have the same variables but different observations. Combine by rows Combine by columns To combine by rows, you can use the function rbind(mydata1, mydata2). The rbind() function takes in two different data types with the same variables. One thing to note is that the column names must match, otherwise, the stacking will not work. df1 = data.frame(var1 = c(0, 3, 1, 2), var2 = c(1, 1, 1, 2), var3 = c(0, 9, 0, 0)) df2 = data.frame(var1 = c(2, 2, 4), var2 = c(3, 1, 9), var3 = c(7, 3, 5)) rbind(df1, df2) Here is what happens when the column names if the column names of the two data frames do not match: Merge Data Sets Merging is a concept similar to the combining of dataframes, but works differently. Typically, a “merge” joins two data frames from different sources or at different times. Here are some requirements to merge two data sets: Both data frames must have at least one variable in common (either character or numeric) If character, make sure the categories have the same spelling (i.e., country names, etc.) If numeric, make sure the units are the same (i.e., kg vs lbs) Example: A study was conducted to identify risk factors for low infant birth weight using data frame 189 live births at Bay State Medical Center in Massachusetts. Low birthweight was defined as a &lt;2500 grams. We have one data set for low birthweight-babies (bwt_Low_2018.csv) and another for normal birthweight babies (bwt_Normal_2018.csv). id= ID number of infant smoke= smoking during pregnancy = 1, if yes; 0 if no age = mother’s age in years We have a separate data set with data on number of visits (bwt_Admin_2018.csv). id = ID number of infant visits = number of physician visits during 1st trimester = 0 if none; 1 if one; 2 if two or more Here is the solution: # Combine the low birthweight babies (bwt_Low_2018.csv) with the normal birthweight babies (bwt_Normal_2018.csv). # This is the combo_row data from above low_birth = read.csv(&quot;bwt_Low_2018.csv&quot;) norm_birth = read.csv(&quot;bwt_Normal_2018.csv&quot;) combo_row = rbind(low_birth, norm_birth) # Merge the combo_row data with data on # of visits (bwt_Admin_2018.csv). # id = ID number of infant # visits = number of physician visits during 1st trimester = 0 if none; 1 if one; 2 if two or more admin_birth = read.csv(&quot;bwt_Admin_2018.csv&quot;) # Read admin data birth_final = merge(combo_row, admin_birth, by=&quot;id&quot;) # merge the combo and admin data by common &quot;id&quot; column birth_final %&gt;% arrange(id) # sort by id names(birth_final) # Provide column names head(birth_final) # Display first 6 rows of merged data frame "],["descriptive-statistics-hypothesis-testing.html", "2 Descriptive Statistics &amp; Hypothesis Testing Descriptive Statistics Basic Hypothesis Testing", " 2 Descriptive Statistics &amp; Hypothesis Testing Descriptive Statistics Descriptive statistics’ purpose is to help describe the basic features of the data. This is all exploratory information. Below, some common measures of describing a continuous variable are listed below: Measures of central tendency (e.g., mean, median) Describes where the “center” of the data is. Mean is also known as the “average”. Median is also known as the 50th percentile. Measures of variability/spread (e.g., standard deviation, interquartile range-IQR, range) Variance is the squared value of the standard deviation. Interquartile range is from the 25th percentile to the 75th percentile. Range is the distance from the minimum to the maximum observation. Here is a list of all the R functions available to provide various descriptive statistics information: mean(mydata): Mean of all numeric variables mean(mydata$myvar): Mean of a selected numeric variable from the dataset median(mydata$myvar): Median: the 50th percentile var(mydata$myvar): Variance sd(mydata$myvar): Standard Deviation min(mydata$myvar): Minimum value max(mydata$myvar): Maximum value range(mydata$myvar): Range: Min-Max quantile(mydata$myvar): Quartiles; Interquartile Range: 25th - 75th percentiles. Continuous vs. Categorical Variables In data files, to be able to determine what kind of descriptive statistics you need to use, you must first understand your data. Typically, determine whether the values in your variable (column) is continuous, or a categorical. A continuous variable is typically one that you can perform a mathematical operation on. These are spread on a continuous range. Some examples of continuous variables can be age, weight, blood pressure, length of stay, and more.If a column contains “Yes/No” values for a question, then it is categorical. One thing to note, is that a column that contains numeric values does not automatically make it a continuous variable. Rather, if seems like the numeric values represent groups (e.g. 0 for no, and 1 for yes), it is actually a categorical variable. The next few sessions explain various ways to calculate descriptive statistics from continuous and categorical variables in R. Continuous Variables To get a quick summary for numeric variables, you can use the summary() function that automatically comes from the base package. This provides the following values: Minimum 1st Quartile Median Mean 3rd Quartile Maximum Here is an example code to get the summary for age column of the low_birth_all data frame. # Put in the variable inside the () summary(low_birth_all$age) Min. 1st Qu. Median Mean 3rd Qu. Max. 14.00 25.00 29.00 29.17 33.00 50.00 You can run the summary() function on the entire data frame, but it will only return meaningful values for columns that contain numeric values. Most manuscripts report the following descriptive statistics: Mean and Standard Deviation Median and Interquartile Range Both are commonly used but, the median and interquartile range is often better to use when you have a “skewed” dataset. This means that the data is not “normally” distributed and leaning more towards a certain value over another (left-tailed, or right-tailed). Medians are not as affected by outliers and skewness as mean values are, so they are better to use if there is any skewed data. For the variability measure to go with the median, use the interquartile range. If the median and mean values are close to each other, then it gives you an idea that the data is relatively normally distributed, so you can use either descriptive statistic measures. If they have a large discrepancy, than there may be skewness in the data, so the median and interquartile range are preferred. A different way to get the summary statistics of variables is to use the skim() function from the skimr package. This provides the following values: n_missing: Number of NA values in the column complete_rate: The percent of rows that do not contain NA values (maximum value is 1) mean: Mean value of numeric column sd: Standard deviation value of numeric column p0: minimum value p25: 25th percentile value p50: median value p75: 75th percentile value p100: maximum value skim(low_birth_all) # input the entire data set When using this function, be cautious of reporting the summary of all columns. This function runs across the entire data frame, so it might generate summaries that are not meaningful. For example, running the skim() function with our low_birth_all data frame generates meaningless summaries for the id variable. The id column is an identifier column for each unique baby. The ht and ptl columns are bivariate (0/1) columns, indicating that they only have values of 0 and 1. This kind of binary variables are actually “categorical” variables. Therefore, this kind of descriptive statistics is not helpful. Frequencies and percentage values will be more informative. Meanwhile, if you would like to generate summary statistics for each level of another categorical variable, the dplyr package and the function group_by() can assist with this task. Here is an example of calculating summary statistics of birthweight bwt by race. low_birth_all %&gt;% # use the low_birth_all data group_by(race) %&gt;% # Group by the race summarize(n = n(), # total number of observations min = min(bwt), # minimum q1 = quantile(bwt, 0.25), # 25th percentile median = median(bwt), # median q3 = quantile(bwt, 0.75), # 75th percentile max = max(bwt)) %&gt;% # maximum as.data.frame(.) %&gt;% # return the result as a dataframe object in R mutate_if(is.numeric, round, 2) # round numeric columns so they have two decimal points race n min q1 median q3 max 1 black 573 280 2780.00 3140.0 3470.00 5115 2 other 390 640 2912.25 3242.5 3516.50 4672 3 white 2708 482 3005.00 3351.5 3666.25 5530 If the numeric/continuous variable that you are retrieving calculations for has any NA values, the functions from above may return as NA. The NA value gets returned because these functions take the NA value into the calculation. But the NA value is not a numeric value, so the R code cannot run the calculation properly and returns NA. One way to work around this is to add in the option of na.rm = T or na.rm = TRUE into your function (e.g. min(mydata$myvar, na.rm = T)). This na.rm option is typically defaulted to FALSE, but we are setting it to TRUE to ensure that we remove any NA values from our calculations. Feel free to check the documentation for these summary statistics functions using the ?function_name() syntax to check if you can do this for a function of interest. Categorical Variables For categorical variables, you can get descriptive statistics by calculating the row, column, and total frequencies and percentages (%). This is typically done through two- and three-way tabulations. Here are some examples: tbl &lt;- table(mydata$var1, mydata$var2) # 2-way table prop.table(tbl, 1) # Row Proportions prop.table(tbl, 2) # Column Proportions prop.table(tbl) # Total Proportions xtabs(~var1 + var2 + var3, data = mydata) # 3-way cross-tabulation To get a 1-way tabulation, you can put a single variable inside the table() function. This will return the frequency of that variable. To return the proportion tables in R, you must input the output of the table() function like the tbl object shown above. An alternative method to run a 3-way tabulation is to use the following functions from the janitor package. tabyl(): A function to generate a frequency table (1-, 2-, or 3-way). show_missing_levels condition set to TRUE if you have any missing data and its percentage. adorn_totals(): Append a totals row and/or column to a data frame. adorn_percentages(): Convert a data frame of counts to percentages. adorn_pct_formatting(): Format a data frame of decimals as percentages adorn_ns(): Add underlying Ns to a tabyl displaying percentages adorn_title(): Add column name to the top of a 2-way tabyl Example: two-way tables of smoke by race stratified by history of hypertension ht (0/1) low_birth_all %&gt;% tabyl(smoke, race, ht, show_missing_levels = FALSE) %&gt;% # adorn_totals(&quot;col&quot;) %&gt;% adorn_percentages(&quot;row&quot;) %&gt;% adorn_pct_formatting(digits = 1) %&gt;% adorn_ns %&gt;% adorn_title $`0` race smoke black other white 0 15.5% (520) 10.8% (364) 73.7% (2471) 1 12.7% (30) 7.6% (18) 79.7% (188) $`1` race smoke black other white 0 27.8% (20) 11.1% (8) 61.1% (44) 1 37.5% (3) 0.0% (0) 62.5% (5) How to Create ‘Table 1’ with gtsummary In R, there is a way to combine the descriptive statistics of both continuous and categorical variables and put them inside a table. This is typically done through the gtsummary package. This table can be copy-pasted into your publication since it was created to generate a nicely formatted table for you. To read more on this package (e.g. tutorial articles are provided here), read more from the documentation website. From this package, you can create the table using the tbl_summary() function to generate a function like the following: With this package, you only need to specify what are the continuous and/or categorical variables and how to visualize the descriptive statistics in the table. The table will then be generated for you. Using the tbl_summary() can also display a p-value to see if there is a statistically significant difference between groups, alongside which test was used to generate the p-values. By default, gtsummary will choose the best statistical tests and use those for the p-values. If you want to specify the test, then you can specify it on your end within the code. Click HERE to view code to generate “Table 1”: # Make the table tab &lt;- low_birth_all %&gt;% select(age, race, smoke, bwt) %&gt;% tbl_summary(by = race, label = list(age ~ &quot;Age&quot;, smoke ~ &quot;Smoking&quot;, bwt ~ &quot;Birthweight&quot;), type = all_continuous() ~ &quot;continuous2&quot;, statistic = list(all_continuous() ~ c(&quot;{mean} ({sd})&quot;, &quot;{median} ({p25}, {p75})&quot;), all_categorical() ~ &quot;{n} / {N} ({p}%)&quot;), digits = all_continuous() ~ 2, missing_text = &quot;(Missing)&quot;) %&gt;% add_p(pvalue_fun = ~style_pvalue(.x, digits = 2)) %&gt;% modify_header(label ~ &quot;**Variable**&quot;) %&gt;% modify_spanning_header(c(&quot;stat_1&quot;, &quot;stat_2&quot;, &quot;stat_3&quot;) ~ &quot;**Race Categories**&quot;) %&gt;% modify_caption(&quot;**Table 1. Patient Characteristics**&quot;) %&gt;% bold_labels() # Export and save the file to HTML tab %&gt;% gtsummary::as_gt() %&gt;% gt::gtsave(., &quot;Table1_Example.html&quot;) # The fille will save automatically to the current working directory Basic Hypothesis Testing Hypothesis testing provides a framework for making decisions on an objective basis rather than on a subjective basis by simply looking at the data. This is usually done when you have a have-defined question in mind. Otherwise, you are at risk of ending up with a false positive result. The null hypothesis (\\(H_{0}\\)): hypothesis to be tested vs. The alternative hypothesis (\\(H_{1}\\)): hypothesis contradicting the null Note that our decisions will always be with respect to the null hypothesis. Note: You either reject the null or fail to reject the null hypothesis. You never “accept” the alternative hypothesis. Student’s T-test A T-test is an analysis of one- or two-population means: Used for continuous (numeric) data (outcomes) One-sample T-test (compare one population mean to a specified value) Two-sample T-test (compare two population means) Independent or paired test Independent samples are not correlated (e.g. treatment and control, male and female). Paired samples means that there is some correlation between two groups (e.g. pre- and post- on the same group at a certain specific time point) Always remember to check model assumptions before inferences: Normality (for small samples) Can be assessed by histograms (check for bell-shaped curve) or QQplots/Normality tests (not covered here) You can also try data transformation (logarithmic, and etc.) to check for normality. You must test for normality on both groups for two-samples. Independent observations within the group(s) (not repeated) One-Sample T-test Hypothesis to be tested (two-sided): \\(H_{0}: \\mu = \\mu_{0}\\) vs \\(H_{1}: \\mu \\ne \\mu_{0}\\) The \\(\\mu_{0}\\) is the value that you want to test. The \\(\\mu\\) is the actual average value of the variable of interest. Example: Is the mother’s average age different from 26? t.test(low_birth_all$age, mu = 26) # mu 0 = 26 One Sample t-test data: low_birth_all$age t = 33.159, df = 3670, p-value &lt; 2.2e-16 alternative hypothesis: true mean is not equal to 26 95 percent confidence interval: 28.98537 29.36059 sample estimates: mean of x 29.17298 Other options that you can change from the default settings of t.test() function are the following: Default alternative = 'two-sided'; Can be changed to alternative = \"less\" or alternative = \"greater\" Default alpha = 0.05 To interpret the p-value, you use the “Type-I Error”. If the p-value is less than the default alpha (0.05), then you reject the null hypothesis. And you have enough evidence to conclude that the mean is actually different from 26. R specifies the alternative hypothesis to be tested as part of the output for you and provides the 95% confidence interval for you. From these values, you can write an interpretation like the following: In the code output, the t.test() function returned a 95% confidence interval of (28.99, 29.36). This can be written in the following manner: We are 95% confident that in this population the true mean mother’s age is between approximately 28.99 and 29.36 years. The 95% confidence interval provides the range of where the true mean can fall. The interpretation of the entire output can be written as: At 0.05 significance level, we reject the null hypothesis (p-value &lt; 0.001) and conclude that the tree mean mother’s age is not equal to 26. Two-Sample T-test Hypothesis to be tested (two-sided): \\(H_{0}: \\mu_{1} = \\mu_{2}\\) vs \\(H_{1}: \\mu_{1} \\ne \\mu_{2}\\) Here, you are comparing the means of two different samples. In the two-sample case, you also need to test for the equality of variances: Testing the equality of variances implies testing the hypotheses: \\(H_{0}: \\sigma^{2}_{1} = \\sigma^{2}_{2}\\) vs \\(H_{1}: \\sigma^{2}_{1} \\ne \\sigma^{2}_{2}\\) 0.05, you can interpret the result from the variance test as below: From the output above, you should see that the p-value returned as 0.11. This value indicates that there is not enough evidence to declare inequality of variances. Then let’s test for equality of means: t.test(bwt_smoke$bwt, bwt_nonsmoke$bwt, var.equal = T, paired = F) Two Sample t-test data: bwt_smoke$bwt and bwt_nonsmoke$bwt t = -5.7962, df = 3669, p-value = 7.355e-09 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -309.8009 -153.1908 sample estimates: mean of x mean of y 3040.893 3272.389 Other options that you can change from the default settings of t.test() function are the following: Default var.equal = FALSE; this can be changed to TRUE if variances are equal Default paired = FALSE; this can be changed to TRUE if the two samples are not independent of each other. The interpretation of the entire output can be written as: At 0.05 significance level, we reject the null hypothesis (p-value &lt; 0.001) and conclude that the true birthweight means for smokers and non-smokers are significantly different. Analysis of Variance (ANOVA) The ANOVA is used to compare (continuous) outcomes of 3 or more groups. To use this test, the following model assumptions must be followed: Independent samples Responses within the groups are independent and identically distributed (i.i.d) Residuals are normally distributed Equality of variances across groups Example: Is mean birthweight of babies significantly different by race? The anova can be run in R using the anova() function. Better to declare the categorical variable/predictor as a factor, otherwise, it will be considered a continuous measurement. # lm : Linear Models # Continuous variable (dependent variable) will be on the left hand side of the ~ # Independent variables on the right hand side of the ~ res &lt;- lm(bwt~factor(race), data = low_birth_all) anova(res) Analysis of Variance Table Response: bwt Df Sum Sq Mean Sq F value Pr(&gt;F) factor(race) 2 28613986 14306993 39.856 &lt; 2.2e-16 *** Residuals 3668 1316696669 358969 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 The interpretation of the entire output can be written as: At 0.05 significance level, we reject the null hypothesis (p-value &lt; 0.001) and conclude that there is a significant difference in mean birthweight by race. But this can raise the question of, “where are these differences coming from?” The following code takes a look at his in more detail: # ANOVA table summary(res) Call: lm(formula = bwt ~ factor(race), data = low_birth_all) Residuals: Min 1Q Median 3Q Max -2824.29 -301.29 49.61 363.71 2223.71 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 3068.39 25.03 122.591 &lt;2e-16 *** factor(race)other 123.54 39.33 3.141 0.0017 ** factor(race)white 237.90 27.55 8.635 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 599.1 on 3668 degrees of freedom Multiple R-squared: 0.02127, Adjusted R-squared: 0.02074 F-statistic: 39.86 on 2 and 3668 DF, p-value: &lt; 2.2e-16 Here you might notice that you do not see the result for the “black” in race variable. This is because it is used as the “reference” category. The values you see are comparisons between other vs. black, and white vs. black. Here, the intercept is the “mean” birthweight of the reference category. From this output, the interpretation can be written as: At 0.05 significance level, we conclude that there are significant differences in mean birthweight between White vs. Black race and Other vs. Black race. To change the reference category, you can do so using relevel() function. One thing to note about ANOVA, is that you cannot use it without first checking a few model assumptions: constant variance and normality of residuals. To check if the model assumptions are followed, you can use the following code: par(mfrow = c(2, 2)) plot(res) In constant variance, you want your residuals vs. fitted values to be scattered (homogeneously distributed) No pattern should be detected If you do see a pattern, then consider changing to a non-parametric test or perform data transformation. For normality of residuals, you want to see a relatively straight line. It might not be a perfectly straight line (especially departures in the tails). If there is a bump(s) within the middle of the plot, this is indicating that the residuals are not normally distributed, so ANOVA might not be the best test to conduct. Categorical Data Analysis Categorical outcome (Y) with 2 levels (binary) or \\(\\ge3\\) levels (nominal or ordinal) Here are some examples: Nominal: race/ethnicity Ordinal: clothing sizes (S, M, L, XL) Binary: Disease/No Disease; Republican/Democrat Predictor variables (X) can take on any form: binary, categorical, and/or continuous. Chi-Square Test of Independence Use two categorical variables (row and column) to test whether they are independent or associated. The hypothesis is as follows: The null hypothesis (\\(H_{0}\\)): variables A and B are independent vs. The alternative hypothesis (\\(H_{1}\\)): variables A and B are not independent The test statistics for the Chi-square test is represented as: \\[X^{2} = \\sum\\frac{(Observed - Expected)^{2}}{Expected}\\] To run the Chi-Square test of independence, follow these steps: Create the (r X c) table r represents the number of levels for the row variable c represents the number of levels for the column variable Most common example is a 2 x 2 table Use the observed and expected counts in each cell to calculate the chi-squared statistics If there are low expected cell counts (&lt;5), use Fisher’s Exact test instead. In R, we can recreate the steps listed above by doing the following: Start by tabulating the two categorical variables Then apply the function chisq.test() Example: Is there an association between smoking and having a low birthweight baby? chisq.test(low_birth_all$smoke, low_birth_all$low) Pearson&#39;s Chi-squared test with Yates&#39; continuity correction data: low_birth_all$smoke and low_birth_all$low X-squared = 10.47, df = 1, p-value = 0.001214 From this output, the interpretation can be written as: At 0.05 significance level, we reject the null hypothesis (p-value = 0.001) and conclude that there is a significant association between smoking and having a low birthweight baby. Note: Remember that association does not mean causality! Fisher’s Exact Test This test is used instead of the Chi-Squared Test when there are low expected cell counts (&lt;5). Example: Is there an association between smoking and having a low birthweight baby? fisher.test(low_birth_all$smoke, low_birth_all$low) Fisher&#39;s Exact Test for Count Data data: low_birth_all$smoke and low_birth_all$low p-value = 0.001768 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 1.250723 2.713328 sample estimates: odds ratio 1.862796 From this output, the interpretation can be written as: At 0.05 significance level, we reject the null hypothesis (p-value = 0.002) and conclude that there is a significant association between smoking and having a low birthweight baby. When compared to the Chi-Squared test result, the p-values are similar. If you are ever in doubt about the count/frequency of your data, use the Fisher’s Exact Test. Multiple Comparisons For multiple comparisons, you might want to consider Tukey adjustment or Bonferroni adjustment to help with potential inflation of the type-I error. If you want to use all-pairwise comparisons, you can use Tukey adjustment to adjust the Type-I error because multiple comparisons typically inflate that value. res &lt;- lm(bwt ~ factor(race), data = low_birth_all) ANOVA &lt;- aov(res) TUKEY &lt;- TukeyHSD(ANOVA) TUKEY Tukey multiple comparisons of means 95% family-wise confidence level Fit: aov(formula = res) $`factor(race)` diff lwr upr p adj other-black 123.5400 31.32304 215.7569 0.0048295 white-black 237.8994 173.30296 302.4958 0.0000000 white-other 114.3594 38.27583 190.4430 0.0012499 The output displays the confidence intervals with the adjustments of the multiple comparisons. The p-values are also adjusted based on the Tukey adjustment for the type-I error. If you want to use the Bonferroni adjustment (which is more conservative than the Tukey adjustment). pairwise.t.test(low_birth_all$bwt, low_birth_all$race, p.adjust.method = &quot;bonf&quot;) Pairwise comparisons using t tests with pooled SD data: low_birth_all$bwt and low_birth_all$race black other other 0.0051 - white &lt;2e-16 0.0013 P value adjustment method: bonferroni The output displays the p-values for each comparisons by race, and indicates that all of these are statistically significant. One suggestion when running ANOVA, is that if the overall ANOVA result returns as statistically significant, then you should move to pairwise comparisons. If the overall ANOVA is not statistically different, then there is no need to run pairwise comparisons, because you will not find anything. "],["data-visualization.html", "3 Data Visualization Basic Plots ggplot2 Plots Other Plots Saving the Plot", " 3 Data Visualization R is a great tool for data visualization. In a lot of situations, it is highly commended for having the tools to provide good looking plots over other coding languages. Basic Plots R provides functions from the base package to allow visualizing some data. To draw some plots, you can use the plot() function and takes in the parameters for the x-axis and y-axis. These will be briefly explained or provided a brief code example since there are stronger, and more visually pleasing visualization options available! Scatterplots Another argument that the function plot can take in is for the type argument. The type can be one of the following: p = Points (this is the default type for plots) l = Lines b = For both; points are connected by a line o = For both “overplotted” h = For histogram like vertical lines s = For stair steps n = For no plotting x &lt;- c(1:10) y &lt;- 2 * x par(mfrow = c(1, 2)) # Function to output side-by-side plots 1 row and 2 columns format plot(x, y) plot(x, y, type = &quot;l&quot;) plot(x, y, type = &quot;b&quot;) plot(x, y, type = &quot;h&quot;) The plot() function can take in further arguments for various features of drawing a plot in R. Some of the important ones are: main = Main Title / Title of the Plot xlab = X-axis title ylab = Y-axis title pch = Marker Style (shape and fill or no fill) frame = Border around the plot col = Change the color fo the markers pch is the option for various marker styles. Here is a list of the various marker types that you can use. These numbers can also be used with the ggplot2 plots as well. And to plot from one of the data columns read into R, the column(s) of interest can be called using the appropriate notation. plot(x = low_birth_all$birthMonth, y = low_birth_all$prenatalVisits, main = &quot;Number of Prenatal Visits by Month&quot;, xlab = &quot;Month&quot;, ylab = &quot;Number of Prenatal Visits&quot;, pch = 19, col = &quot;blue&quot;) Line Plots Using the plot() function, the type=l argument or type=b can be used to draw line plots. # Want to plot just the non-smokers x &lt;- c(1:10) y &lt;- x^2 plot(x = x, y = y, type = &quot;b&quot;, pch = 19) Bar Plots To draw the barplots using the base R package, the following can be done: low_bwt_table &lt;- low_birth_all %&gt;% group_by(birthMonth) %&gt;% summarize(prenatalVisits = n()) barplot(height = low_bwt_table$prenatalVisits, names.arg = unique(low_bwt_table$birthMonth)) Notice that the height is for the y-axis and the width stands for the x-axis here. Histogram and Density Plots To look at the distribution of the data for certain values, histograms and density plots are also useful. The following is an example of the basic method to do so: set.seed(42) x &lt;- c(rnorm(400, mean=50, sd=5), rnorm(400, mean=75, sd=5)) dens &lt;- density(x) par(mfrow = c(1, 2)) hist(x, col = &quot;steelblue&quot;, breaks = 30) plot(dens, col = &quot;steelblue&quot;, main = &quot;Density Plot Example&quot;) Boxplots For a different form of distribution visualization, a boxplot is also popular. The following is an example of the basic method to do so: boxplot(prenatalVisits ~ birthMonth, data = low_birth_all) However, although these plots are relatively “simple” to code, they have limited capabilities design-wise. For more design capabilities, you can use ggplot2 and plotly packages. ggplot2 Plots The ggplot2 package is commonly used for data visualization in R. Although base plots can be visualized in a quick and easy manner, they are not the most aesthetic of plots. The ggplot2 package provides more aesthetic options and more flexibility. The ggplot2 plot requires three elements: data aesthetic mapping using the aes() argument This helps to specify x, y variables, alongside the color and fill (these are determined by categorical values). at least one layer created with the geom function This specifies the type of plot that gets generated. geom_point = Scatter Plot geom_density = Density Plot geom_line = Line Plot geom_histogram = Histogram geom_bar = Bar plot geom_smooth = Smooth line such as regression line geom_text = Text annotations geom_boxplot = Box plot geom_violin = Violin plot geom_dotplot = Dot plot There are several more geom layers available in ggplot2 that has not been listed above. These can be explored further online. For this guide, the most commonly plotted geom layers will be demonstrated. In ggplot2, to draw a plot, the first line of code always starts with the ggplot(). This function requires two of the three components mentioned before: data and the aesthetic mapping. In the aesthetic mapping, you can type in the column names for the x and y-axes. These column names do not require quotation marks. There are two more key other features of aesthetic mapping available: color and fill. The options for color and fill are optional features, but these are useful when you want to use color to represent unique categorical values. color and fill might sound similar option-wise, but there is a slight difference: color option colors the plot type for each unique categorical value In certain options, the color option is more for the outline color in the geom layer. fill option colors the plot type for each unique categorical value but actually fills in the geom layer. Using either color or fill or both, this automatically generates a legend to the right-hand side of the plot in ggplot2. Doing so allows the user to know which color is assigned to which value. To learn more about dealing with color and fill in R, click here. The structure of the ggplots typically first call the ggplot() function, which is followed up by the + symbol. After, the geom layer of interest can be added. To add more layers or change the way elements look, keep adding the + symbol after you finish that line of code. Here is an example of ggplot code in R: ggplot(data = mydata, aes(x = x_var_name, y = y_var_name)) + geom_point() One other thing to note is that there are various other features available for drawing plots through ggplot2 package. You are able to manually change colors instead of using the default palettes, change the background design of the plot, or the overall plot theme. This will be highlighted in later sections of this chapter. Scatterplots The scatter plot shows the relationship/trend between two continuous (numerical) variables. Example: Draw the scatter plot of age by birthweight bwt. ggplot(low_birth_all, aes(x = age, y = bwt)) + geom_point(color = &quot;blue&quot;) + # Color the points blue labs(title = &quot;Scatterplot of age by birthweight&quot;) + # Add in a title labs(x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) # Relabel the x and y-axes titles When you plot a scatter plot in R, you also have the option drawing a regression line using the geom_smooth() function. This is typically used to draw a straight line between the x and y-axes. ggplot(low_birth_all, aes(x = age, y = bwt)) + geom_point(color = &quot;blue&quot;) + geom_smooth(method = &quot;lm&quot;, se = T, col = 2) + # Draw a straight line and add in the standard error line labs(title = &quot;Scatterplot of age by birthweight&quot;, # Add title x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) # Relabel x and y-axes titles Within the geom_point() function, there are multiple options that you could use to help advance your visualization. Color and fill arguments can be done inside the ggplot() function, and highly suggested. But it can also be done inside the geom_point function if wished. However, the point shape, size, and transparency can be set in the geom_point function. This information can help illustrate how different groups within a categorical variable are distributed across the other two features of interest. Example: Overlaid scatterplots and regression lines by smoke status. ggplot(low_birth_all, aes(x=age, y=bwt, color = factor(smoke))) + # Set color to vary on smoking status geom_point() + # Draw scatter plot geom_smooth(method = &quot;lm&quot;, se=F, aes(group = factor(smoke))) + # Draw regression lines by smoking labs(title = &quot;Scatterplot of age by birthweight&quot;, # Add title and relabel axes titles x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) + scale_color_manual(name = &quot;Smoking Status&quot;, # Change the legend title labels = c(&quot;No&quot;, &quot;Yes&quot;), # Re-code the values 0=no; 1= yes for smoking status values = c(&quot;blue&quot;, &quot;red&quot;)) + # Specify what colors each value should be. theme_classic() # change theme from default to classic. To change the shape of the points, use the shape = argument inside the geom_point function. The shape argument takes in numbers from the image above with the various pch options. For colored and fill options, you can use numbers 15 through 25. ggplot(low_birth_all, aes(x=age, y=bwt, color = factor(smoke))) + # Set color to vary on smoking status geom_point(aes(shape = factor(smoke))) + # Draw scatter plot labs(title = &quot;Scatterplot of age by birthweight&quot;, # Add title and relabel axes titles x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) + scale_shape_manual(name = &quot;Smoking Status&quot;, # Change the legend title labels = c(&quot;No&quot;, &quot;Yes&quot;), # Re-code the values 0 = no; 1 = yes values = c(4, 19)) + # Specify what shapes each value should be scale_color_manual(name = &quot;Smoking Status&quot;, # Change the legend title labels = c(&quot;No&quot;, &quot;Yes&quot;), # Re-code the values 0=no; 1= yes for smoking status values = c(&quot;blue&quot;, &quot;red&quot;)) + # Specify what colors each value should be. theme_classic() # change theme from default to classic. One thing to note is that pch options 15 through 20 for shapes have the same fill color and border color, so you only need to define the color argument. However, pch options 21 through 25 have a separate border color and fill color option and you can set it so that they differ from each other. This can be demonstrated as the following: ggplot(low_birth_all, aes(x = age, y = bwt)) + geom_point(color = &quot;black&quot;, fill = &quot;steelblue&quot;, shape = 21) + # Color the points blue but line them black labs(title = &quot;Scatterplot of age by birthweight&quot;) + # Add in a title labs(x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) # Relabel the x and y-axes titles Another option that you can use is to change the size of the markers/points of the plots. You can define this using the size = argument in geom_point() as portrayed below: ggplot(low_birth_all, aes(x = age, y = bwt)) + geom_point(color = &quot;black&quot;, fill = &quot;steelblue&quot;, shape = 21, size = 3) + # Change the size to 3 (bigger) labs(title = &quot;Scatterplot of age by birthweight&quot;) + # Add in a title labs(x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) # Relabel the x and y-axes titles This last option that might be of interest is the alpha argument. This argument deals with the “opacity” of the markers/graph element. The input is a decimal value that determines the transparency of points. If you would like to see points that may be overlapping each other, you can set the alpha to a value of 0.4 to 0.6 (commonly used values) for semi-transparent points. ggplot(low_birth_all, aes(x = age, y = bwt)) + geom_point(color = &quot;black&quot;, fill = &quot;steelblue&quot;, shape = 21, size = 2, alpha = 0.5) + # Set the point transparency to 0.5 labs(title = &quot;Scatterplot of age by birthweight&quot;) + # Add in a title labs(x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) # Relabel the x and y-axes titles Barplots Bar plots are typically used to display the count information of categorical data. In R, this is mostly done through geom_bar() function. This function makes the “height” of the bar (y-axis) proportional to the number of cases in each group (x-axis values). Essentially, this function does a calculation with the function called stat_count() to count the number of cases of each group indicated by the x-axis. This function works best if there is no “count” value in the data frame already. Example: Bar plot of total number of participants by race. ggplot(low_birth_all, aes(x = race, fill = race)) + geom_bar() + # Draw Bar plot ggtitle(&quot;Barplot of Number of People by Race&quot;) + # Add title labs(x = &quot;Race&quot;, y = &quot;Number of Participants&quot;) + # Relabel the axes titles theme_minimal() # Change plot theme However, this is the case only if each row is a unique participant like this data. If we wanted to represent the total value of a continuous variable instead of the count, then we can use the stat = \"identity\" argument. This allows you to not have to manually transform the data. All you have to do is specify the y-axis and set the argument to stat = \"identity\". For bar plots, you can also combine multiple bar plots into one by inputting the fill= argument in the aes() function. The default is set to “stack” the bars on top of each other, but if you wanted them side-by-side, add in the position = \"dodge\" argument within the geom_bar() function. Example: bar plot of total number of prenatal visits for each race by smoking status ggplot(low_birth_all, aes(x = race, y = prenatalVisits, fill = factor(smoke))) + # Add two different bars by smoke status geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + # Draw total of prenatal Visits for y-axis and side-by-side bars ggtitle(&quot;Barplot of Number of Prenatal Visits by Race&quot;) + # Add title labs(x = &quot;Race&quot;, y = &quot;Number of Prenatal Visits&quot;) + # Relabel the x and y-axes titles scale_fill_manual(name = &quot;Smoking Status&quot;, labels = c(&quot;No&quot;, &quot;Yes&quot;), # Format the legend for the color of bars values = c(&quot;blue&quot;, &quot;red&quot;)) + theme_minimal() # Change the theme of the plot There is an alternative way to draw plots in ggplot2 and that is through the geom_col() function instead of the geom_bar() function. This function does not transform the data like geom_bar() does. If your data already contains a certain “count” data in a variable already, then this function should work better than the geom_bar() function. If it does not contain the count data, then you have to calculate it on your own end. count_bwt &lt;- low_birth_all %&gt;% # Calculating the count of all unique races. group_by(race) %&gt;% summarize(Count = n()) %&gt;% as.data.frame(.) ggplot(count_bwt, aes(x = race, y = Count, fill = race)) + geom_col() + ggtitle(&quot;Barplot of Number of People by Race&quot;) + # Add title labs(x = &quot;Race&quot;, y = &quot;Number of Participants&quot;) + # Relabel the axes titles theme_minimal() # Change plot theme Histogram Histograms show the underlying frequency distribution of continuous data. In ggplot2, histograms plot with a default “bin” value of 30. To alter this, use the argument binwidth. This will override the bin value and adjust to the value you set. Sometimes, R will advise you to override their default, but it is up to your discretion to adjust this value. Example: Histogram of the continuous variable birthweight bwt with a vertical red reference line added to show the mean birthweight ggplot(low_birth_all, aes(x = bwt)) + geom_histogram(col = &quot;black&quot;, fill = &quot;pink&quot;, breaks = seq(200, 5000, 300)) + geom_vline(aes(xintercept = mean(bwt, na.rm = T)), color = &quot;red&quot;, linetype = &quot;dashed&quot;, size = 1.25) + labs(title = &quot;Histogram of low birthweight&quot;, x = &quot;Birthweight (g)&quot;, y = &quot;Count&quot;) You can also add multiple histograms in one plot by using the fill argument again. Here is an example: Example: Histogram of the continuous variable birthweight bwt with a vertical red reference line added to show the mean birthweight. ggplot(low_birth_all, aes(x=bwt, fill=factor(smoke))) + # Draw two histograms by smoke status geom_histogram(binwidth = 0.5, alpha = 0.5, position = &quot;identity&quot;, # alter binwidth and set transparency level col = &quot;black&quot;, breaks = seq(200, 5000, 300)) + geom_vline(aes(xintercept = mean(bwt, na.rm = T)), color = &quot;red&quot;, # Add the line at the mean birthweight value linetype = &quot;dashed&quot;, size = 1.25) + labs(title = &quot;Histogram of low birthweight&quot;, # Add title and relabel axes titles x = &quot;Birthweight (g)&quot;, y = &quot;Count&quot;) + scale_fill_discrete(name = &quot;Smoking Status&quot;, labels = c(&quot;No&quot;, &quot;Yes&quot;)) # Format the legend Boxplots Boxplots show the underlying distribution of continuous data based on the five number summary statistics: minimum, 1st quartile, median, 3rd quartile, and maximum. This takes in the categorical variable for the x-axis and the continuous variable for the y-axis. Example: boxplots of bwt by smoke status ggplot(low_birth_all, aes(x = factor(smoke), y = bwt, fill = factor(smoke))) + geom_boxplot() + labs(title = &quot;Boxplot of baby birthweight&quot;, x = &quot;Smoking Status&quot;, y = &quot;Count&quot;) + scale_fill_discrete(name = &quot;Smoking Status&quot;, labels = c(&quot;No&quot;, &quot;Yes&quot;)) In a similar fashion as before, you can plot multiple groups of barplots into one, singular plot by taking advantage of the fill argument. Example: Compare race by smoke status with respect to birthweight bwt variable. ggplot(low_birth_all, aes(x = race, y = bwt, fill = factor(smoke))) + geom_boxplot() + scale_fill_manual(values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;Non-Smokers&quot;, &quot;Smokers&quot;)) + labs(x = &quot;Race&quot;, y = &quot;Birthweight (g)&quot;) + theme(legend.position = &quot;top&quot;, legend.title = element_blank()) Formatting Plots Most of the common figure types have been covered. However, there is the issue of formatting ggplot2 plots, which can seem daunting with endless resources. However, there are functions called facet_wrap() and facet_grid() that can assist you with separating out those combined plots into multiple ones to help visualize the distribution of your data side-by-side. facet_wrap(): This will generate a grid of plots for the combination of variables that have values. facet_grid(): This will generate a grid of plots for each combination of values of variables that you specify, even if some plots are empty. With this in mind, it is preferable to use facet_wrap() over facet_grid() unless you are doing very preliminary data exploration. Within the function, you can specify certain values, but you must designate the facet through by placing vars(variable_name) as the first element of the function. If you want to designate the number of columns and/or rows for the grid of multiple plots, you can change the values by designating nrow= and ncol= inside the facet_wrap() function. Any other editing done within the theme() function you want to do affects all of the plots set in the grid because these are still outputted as a single graphic object in R. Example: Compare race by smoke status with respect to birthweight bwt variable. ggplot(low_birth_all, aes(x = factor(smoke), y = bwt, fill = factor(smoke))) + geom_boxplot() + scale_fill_manual(values = c(&quot;blue&quot;, &quot;red&quot;), labels = c(&quot;Non-Smokers&quot;, &quot;Smokers&quot;), name = &quot;Smoking Status&quot;) + labs(x = &quot;Smoking Status&quot;, y = &quot;Birthweight (g)&quot;) + facet_wrap(vars(race)) theme() function This section is not covered in the course series, but here to help clarify any confusion that you may run into while coding in R. In ggplot2, there is a function called theme() that you can use to do some additional plot formatting. For instance, you can adjust the spacing between the axes titles with the plot, align the title to the center of the plot, remove grid lines in the plot, and much more. Below is some code that might help you as you write your own code to do data visualizations from one of the previous examples: ggplot(low_birth_all, aes(x = age, y = bwt)) + geom_point(color = &quot;blue&quot;) + geom_smooth(method = &quot;lm&quot;, se = T, col = 2) + labs(title = &quot;Scatterplot of age by birthweight&quot;, x = &quot;Age (yrs)&quot;, y = &quot;Birthweight (g)&quot;) + theme(plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;, size = 11), # Center-align, bold font, and set font size to 11 for title axis.title.x = element_text(margin = margin(t = 10, r=0, b=0, l=0)), # Add some space between the x-axis and its title axis.title.y = element_text(margin = margin(t=0, r = 10, b=0, l=0)), # Add some space between the y-axis and its title panel.grid.minor = element_blank(), # Hide the minor grid lines legend.position = &quot;none&quot;, # Hide the legend ) To learn more about the various elements that you can personally modify in ggplot2, read this documentation. Other Plots Forest Plot Forest plots are visual representations of effect sizes and 95% confidence intervals (CI). It can be used to plot several variables of the same study or across studies (meta-analysis). To draw this, there are various methods in R. But there is a way to manually do it in R through ggplot2. First, make sure to have a data that contains a list of items that you want to plot with their names, a column of Odds Ratio, and two separate columns with the lower and upper 95% confidence interval values for each one. Once you have your data set, then you can draw your forest plot using these column values. The key point here is to take advantage of the geom_errorbarh() function, which lets you draw the confidence interval bounds. Another key function is the theme() function explained before, where you format how the figure looks. Here is an example code of a sample data file: forest_plot &lt;- ggplot(or.df, aes(x = OR, y = Index)) + geom_point(shape = 18, size = 3) + geom_errorbarh(aes(xmin = Lower, xmax = Upper), height = 0.25) + geom_vline(xintercept = 1, color = &quot;gray29&quot;, linetype = &quot;dashed&quot;, cex = 1, alpha = 0.5) + scale_y_continuous(name = &quot;&quot;, breaks = 1:10, labels = or.df$Symptom, trans = &quot;reverse&quot;) + xlab(&quot;Odds Ratio (95% CI)&quot;) + ylab(&quot; &quot;) + ggtitle(&quot; &quot;) + theme_bw() + xlim(c(0, 3)) + theme(panel.border = element_blank(), panel.background = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(hjust = 0.5, face = &quot;bold&quot;, size = 11), axis.line = element_line(colour = &quot;black&quot;), axis.text.y = element_text(size = 10, colour = &quot;black&quot;), axis.text.x.bottom = element_text(size = 10, colour = &quot;black&quot;), axis.title.x = element_text(size = 10, colour = &quot;black&quot;, margin = margin(t = 10, r = 0, b = 0, l = 0))) forest_plot Correlation Matrix Correlation measures the strength of a (linear) association between two continuous variables. Correlation values range from -1 to +1: A correlation of -1 indicates a perfect negative correlation between two continuous variables. A correlation of +1 indicates a perfect positive correlation between two continuous variables. You can calculate the correlations using the cor() function which comes with R. However, to plot a correlation matrix, you must use the function corrplot() from the package corrplot. Example: use R built-in data mtcars to show linear correlations between several continuous car characteristics. cor(mtcars[,c(1, 3:7)]) %&gt;% corrplot(method = &quot;circle&quot;, type = &quot;upper&quot;, diag = F) Interactive Plots: Plotly Recently interactive plots have started to surface in the realm of both Python and R. One such tool is the plotly package. The library allows you to either write a plot_ly() figure from scratch, or to transform your ggplot() into a plotly-like figure. In plotly, the plot_ly() function requires the following elements: data x and y variable names plot type marker/trace This is similar to what we call the “geom” layer in ggplot. But let’s say that you already wrote a figure using ggplot. No worries, just assign this to a variable name, and then put it inside the function ggplotly(). Doing so, you will see the interactive features pop up just like the plot_ly() function does. There are additional features available for plotly figures: Hover (information from hover) Zoom in/out Download button Click/drag features Although the two functions both generate an interactive plot, ggplotly() requires a ggplot figure as an input and builds that into an interactive one. To format the ggplot further, you must use the layout() function the way it is demonstrated from the plotly documentation. Example: Draw a scatterplot of the iris dataset with Sepal.Length as the x-axis and the Petal.Length as the y-axis. fig &lt;- ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + geom_point(color = &quot;blue&quot;) ggplotly(fig) plot_ly(data = iris, x = ~Sepal.Length, y = ~Petal.Length, type = &quot;scatter&quot;, mode = &quot;markers&quot;) Example: Draw a scatter and line plot of World Health Organization’s dataset with Year as the x-axis and the Percent of Cause-Related Death Percent as the y-axis (color by country optional). fig &lt;- ggplot(ihd.df, aes(x = Year, y = Cause_Percent, color = Country)) + geom_line() + geom_point(aes(fill = Country, text = paste(&quot;&lt;b&gt;Year:&lt;/b&gt; &quot;, Year, &quot;&lt;br&gt;&quot;, &quot;&lt;b&gt;Country:&lt;/b&gt; &quot;, Country, &quot;&lt;br&gt;&quot;, &quot;&lt;b&gt;Percent:&lt;/b&gt; &quot;, round(Cause_Percent, 2), &quot;%&quot;, sep = &quot;&quot;)), shape = 21, color = &quot;grey50&quot;, size = 3, alpha = 0.5) + scale_x_continuous(breaks = ihd.df$Year, labels = ihd.df$Year) + ylab(&quot;Percent of IHD Related Deaths (%)&quot;) + ggtitle(&quot;Percent of IHD Related Deaths per Year by Country&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;, plot.title = element_text(hjust = 0.5)) fig &lt;- ggplotly(fig, tooltip = &quot;text&quot;) %&gt;% layout(yaxis = list(title = list(standoff = 20L)), xaxis = list(title = list(standoff = 20L))) fig For more plot options from plotly and more documentation, please go to plotly’s website. Saving the Plot In R, a graphics device is a tool that makes your plot appear within RStudio. A window on your computer (screen device) This is the most common place to “send” a plot Easy to copy/paste into your document The file type options available to save your figure(s) are the following: PDF PNG JPEG These options provide better quality for journal articles and/or presentations. Example: create a plot that gets saved in a PDF file: pdf(file = &quot;CorrMat.pdf&quot;) # Save the plot below as a PDF par(mar = c(4, 5, 1, 1)) # Enlarge the dimension of the plot cor(mtcars[,c(1, 3:7)]) %&gt;% # Draw the plot corrplot(method = &quot;circle&quot;, type = &quot;upper&quot;, diag = F) dev.off() # Finish process and turn it off. "],["resources.html", "4 Resources CRAN repository R and RStudio Guides Other R Package Guides Data Visualization Example Datasets", " 4 Resources CRAN repository Website: https://cran.r-project.org/ Current R Version: “Innocent and Trusting” 4.2.2 Released 10/31/2022 R and RStudio Guides Downloading RStudio: Website: https://posit.co/download/rstudio-desktop/ Downloading RTools: Website: https://cran.r-project.org/bin/windows/Rtools/ Posit Guides: Keyboard Shortcut: https://support.posit.co/hc/en-us/articles/200711853-Keyboard-Shortcuts-in-the-RStudio-IDE Cheatsheets: https://posit.co/resources/cheatsheets/ Other R Package Guides gtsummary Documentation: Tutorial: https://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html Data Visualization ggplot2 Guide: https://r-graph-gallery.com/ggplot2-package.html plotly R Gallery (tutorials and documentation): https://plotly.com/r/ R Colors: Colors in R Cheat Sheet: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf ggplot2 color names: http://sape.inf.usi.ch/quick-reference/ggplot2/colour Color Palettes: https://www.datanovia.com/en/blog/top-r-color-palettes-to-know-for-great-data-visualization/ Example Datasets The following list of data files are those retrieved from publicly available databases. The data files from CDC and WHO were contain only a sample of much larger datasets that are publicly available. Lowbwt_ALL.csv is a dataset retrieved from CDC’s public 2018 natality cohort dataset. IHD_WHO_Mortality.csv is a dataset retrieved from WHO’s (World Health Organization) public mortality database. The data is for Ischemic Heart Disease (IHD) mortality data across all ages and all sexes for several countries. Odds_Ratio.csv is a self-generated, random dataset used to help visualize Odds Ratio. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
